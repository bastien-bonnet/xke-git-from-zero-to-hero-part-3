= Git from zero to hero: 3. Nom de l'atelier
:Author: Bastien Bonnet, Alexandre Dergham
:toc:
:numbered: 1

== Pré-requis

. Avoir Git installé

. Récupérer le projet en local

	git clone https://github.com/bastien-bonnet/xke-git-from-zero-to-hero-part-3.git

. Se placer dans le répertoire du projet cloné

	cd xke-git-from-zero-to-hero-part-3

. Pour visualiser l'historique des commits sous forme de graphe compact, nous rajoutons un alias `git l`:

	git config alias.l 'log --graph --oneline --color --decorate --all'
+
N'hésitez pas à utiliser cet alias avant et après chaque commande de l'atelier pour bien visualiser les changements apportés par chaque commande lancée.
+
Pour utiliser l'alias que nous venons de définir (ne fonctionne que pour le projet git dans lequel nous l'avons déclaré) :

	git l

. Définir votre éditeur de texte préféré pour Git (commande à taper dans le terminal dans lequel vous réalisez l'exercice) :

	export EDITOR=nano
+
Remplacez `nano` par l'éditeur de votre choix (vim, emacs, gedit, kate…)


== Introduction
=== Programme de l'atelier

Ceci est le troisième atelier d'une série de trois sur l'utilisation de Git

Les objectifs de cette séance sont d'apprendre à :

* Déterminer le commit qui introduit une régression en utilisant git bisect.
* Appliquer une modification isolée avec la commande cherrypick
* Savoir ce qui se cache derrière la commande git pull
* Etre en mesure de résoudre les problèmes liés à la modification d'une branche distante suite à un git push --force
* Choisir un mode de travail adapté à votre projet (Pull-request, git flow, dictateur&lieutenant)

=== Préambule

== Exercices

=== Localiser un commit qui introduit une régression
Dans cet exercice, nous allons détecter la référence d'un commit qui apporte une "régression".
Pour cela, nous allons utiliser la commande `bisect` de git.
Cette commande nous permet de rechercher un commit par dichotomie en testant des sous-ensembles de commits de plus en plus petits.

* `git checkout master`
* ouvrez le fichier A.txt et constatez que le fichier contient le texte **'Bye Bye!'** (Le comportement souhaité étant de contenir **'Hello world'**).
* `git bisect start` : cette commande initie un contexte de recherche de commit par dichotomie
* `git bisect bad` : cette commande indique que le commit actuel (master) inclus l'anomalie testée.
* `git bisect good ccdd677` : cette commande indique que le commit dont la clé SHA-1 est ccdd677 ne comporte pas l'anomalie testée. A ce moment là, git va vous sélectionner un commit situé exactement au milieu de la serie de commit délimitée par le commit que l'ont a défini comme bon et celui qui est défini comme mauvais.
* ouvrez le fichier A.txt et regardez son contenu.

A partir de là, 2 possibilités s'offrent à vous :

* Le fichier A.txt **est conforme** au comportement recherché dans le commit sélectionné par git : tapez la commande `git bisect good`
* Le fichier A.txt **n'est pas conforme** au comportement recherché : tapez la commande `git bisect bad`

Dans les 2 cas, git redéfinira les bornes de la recherche en fonction de votre réponse et vous proposera un autre commit ainsi qu'une estimation du nombre maximum d'itérations nécessaires pour trouver le commit qui a introduit la régression.

* Recommencez la procédure jusqu'à ce que git vous annonce avoir trouvé le commit incriminé : notez la clé SHA-1 du commit
* quittez le mode bisect en tapant la commande `git bisect stop` : cette commande repositionne le HEAD et l'état du file system à l'état qui a précédé l'entré dans le mode bisect.
* une fois le commit détecté, vous pouvez créer un commit 'inverse' de ce commit pour inverser ses modifications : `git revert xxxxx` où xxxxx est la clé SHA-1 que vous aviez notée.

=== La même en mieux! Automatiser la recherche du commit
Dans cet exercice, nous allons automatiser la recherche du commit en laissant à un script le soin de tester la validité du fichier A.txt à chaque étape du parcours par dichotomie.
Pour cela, nous avons préparé un script `testMyFile.sh` qui retourne 0 si le fichier contient **'Hello world'**. Sinon, il retourne 1.

* `git checkout master`
* `cp ./testMyFile.sh ../.` (Nous copions le script de test hors du répertoire géré par git. Le but étant de ne pas perdre le script pendant le parcours de git bisect.).
* `git bisect start`
* `git bisect bad`
* `git bisect good ccdd677`
* `git bisect run ../testMyFile.sh`
* `git bisect reset` (pour mettre fin au contexte bisect)

A ce moment là, git bisect parcours l'arbre de révision en executant le script à chaque itération. A terme, la commande retourne l'identifiant du commit que nous cherchions.

=== Prélever et appliquer les modifications d'un commit isolé d'une branche à l'autre.
Ici, nous allons nous intéresser au fichier B.txt.
Nous souhaitons appliquer à ce fichier une correction introduite par un commit situé sur une autre branche dans pour autant inclure toutes les modifications apportées par cette branche.
Afin d'y arriver, nous allons utiliser la commande `cherry-pick` qui crée un commit à partir des modifications introduites par un seul commit.

* `git checkout master`
* `git l` : vous constatez la présence d'une branche nommée `cherrypick`. Parmis les commits de cette branche, vous voyez 1 commit `cherry pick me` situé entre 2 commits indésirables.
* `git cherry-pick ddfd83a`
* `git l` : vous voyez l'apparition d'un nouveau commit sur la branche master
* comparez les résultats de `git diff HEAD~2 HEAD` et `git diff 4209c62 ddfd83a`. Vous constaterez que la même modification a été appliquée dans les deux branches.

=== Créer et appliquer un patch
Git fournit la possibilité de crééer des patchs, c'est-à-dire des fichiers contenant un ensemble de changements à appliquer à du code. Cela peut servir, par exemple, à appliquer des changements déjà versionnés dans un autre dépôt, ou bien à partager des changements avec un collègue en cas de perte de réseau.

Cela se fait en deux temps : création du patch (fichier), puis application du patch.

==== Créer le patch
Nous allons créer un patch contenant les modifications apporté par le dernier commit. Gardez à l'esprit qu'un patch peut contenir les modification d'un ensemble de commits.

Créons le patch :

    git format-patch --stdout master~1..master > my_patch.patch

Nous observons qu'un

Pour simuler un dépôt dans un état dans lequel il manque les modifications apportées par le patch que nous venons de créer, nous allons retirer le dernier commit :

    git reset --hard HEAD~1


==== Appliquer le patch
Avant d'appliquer un patch, une bonne pratique est de regarder ce que ce patch va apporter comme modifications :

    git apply --stat my_patch.patch

Une fois cela fait, une autre bonne pratique est de regarder si l'application du patch va causer des problèmes (conflits) :

    git apply --check my_patch.patch

Si rien n'est affiché, il n'y aura pas de problème. Ce devrait être le cas dans cet atelier.

Enfin, nous pouvons donc appliquer réellement le patch :

    git am < my_patch.patch

Cette dernière commande applique le patch et effectue un commit avec son contenu, jusqu'à l'écriture du message de commit.

Vérifier que vous avez bien effectué un nouveau commit avec notre alias :

    git l
